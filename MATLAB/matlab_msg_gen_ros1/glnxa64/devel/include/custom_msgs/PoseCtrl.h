// Generated by gencpp from file custom_msgs/PoseCtrl.msg
// DO NOT EDIT!


#ifndef CUSTOM_MSGS_MESSAGE_POSECTRL_H
#define CUSTOM_MSGS_MESSAGE_POSECTRL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace custom_msgs
{
template <class ContainerAllocator>
struct PoseCtrl_
{
  typedef PoseCtrl_<ContainerAllocator> Type;

  PoseCtrl_()
    : fl_x(0.0)
    , fl_z(0.0)
    , fr_x(0.0)
    , fr_z(0.0)
    , f_pitch(0.0)
    , f_delta(0.0)
    , bl_x(0.0)
    , bl_z(0.0)
    , br_x(0.0)
    , br_z(0.0)
    , b_pitch(0.0)
    , b_delta(0.0)  {
    }
  PoseCtrl_(const ContainerAllocator& _alloc)
    : fl_x(0.0)
    , fl_z(0.0)
    , fr_x(0.0)
    , fr_z(0.0)
    , f_pitch(0.0)
    , f_delta(0.0)
    , bl_x(0.0)
    , bl_z(0.0)
    , br_x(0.0)
    , br_z(0.0)
    , b_pitch(0.0)
    , b_delta(0.0)  {
  (void)_alloc;
    }



   typedef double _fl_x_type;
  _fl_x_type fl_x;

   typedef double _fl_z_type;
  _fl_z_type fl_z;

   typedef double _fr_x_type;
  _fr_x_type fr_x;

   typedef double _fr_z_type;
  _fr_z_type fr_z;

   typedef double _f_pitch_type;
  _f_pitch_type f_pitch;

   typedef double _f_delta_type;
  _f_delta_type f_delta;

   typedef double _bl_x_type;
  _bl_x_type bl_x;

   typedef double _bl_z_type;
  _bl_z_type bl_z;

   typedef double _br_x_type;
  _br_x_type br_x;

   typedef double _br_z_type;
  _br_z_type br_z;

   typedef double _b_pitch_type;
  _b_pitch_type b_pitch;

   typedef double _b_delta_type;
  _b_delta_type b_delta;





  typedef boost::shared_ptr< ::custom_msgs::PoseCtrl_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::custom_msgs::PoseCtrl_<ContainerAllocator> const> ConstPtr;

}; // struct PoseCtrl_

typedef ::custom_msgs::PoseCtrl_<std::allocator<void> > PoseCtrl;

typedef boost::shared_ptr< ::custom_msgs::PoseCtrl > PoseCtrlPtr;
typedef boost::shared_ptr< ::custom_msgs::PoseCtrl const> PoseCtrlConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::custom_msgs::PoseCtrl_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::custom_msgs::PoseCtrl_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::custom_msgs::PoseCtrl_<ContainerAllocator1> & lhs, const ::custom_msgs::PoseCtrl_<ContainerAllocator2> & rhs)
{
  return lhs.fl_x == rhs.fl_x &&
    lhs.fl_z == rhs.fl_z &&
    lhs.fr_x == rhs.fr_x &&
    lhs.fr_z == rhs.fr_z &&
    lhs.f_pitch == rhs.f_pitch &&
    lhs.f_delta == rhs.f_delta &&
    lhs.bl_x == rhs.bl_x &&
    lhs.bl_z == rhs.bl_z &&
    lhs.br_x == rhs.br_x &&
    lhs.br_z == rhs.br_z &&
    lhs.b_pitch == rhs.b_pitch &&
    lhs.b_delta == rhs.b_delta;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::custom_msgs::PoseCtrl_<ContainerAllocator1> & lhs, const ::custom_msgs::PoseCtrl_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace custom_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::custom_msgs::PoseCtrl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::custom_msgs::PoseCtrl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::custom_msgs::PoseCtrl_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "865803d76e3ad519e963faa7db0e7f17";
  }

  static const char* value(const ::custom_msgs::PoseCtrl_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x865803d76e3ad519ULL;
  static const uint64_t static_value2 = 0xe963faa7db0e7f17ULL;
};

template<class ContainerAllocator>
struct DataType< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "custom_msgs/PoseCtrl";
  }

  static const char* value(const ::custom_msgs::PoseCtrl_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Front Left\n"
"float64        fl_x\n"
"float64        fl_z\n"
"\n"
"# Front Right\n"
"float64        fr_x\n"
"float64        fr_z\n"
"\n"
"# Front Body\n"
"float64        f_pitch\n"
"float64        f_delta\n"
"\n"
"# Rear Left\n"
"float64        bl_x\n"
"float64        bl_z\n"
"\n"
"# Rear Right\n"
"float64        br_x\n"
"float64        br_z\n"
"\n"
"# Rear Body\n"
"float64        b_pitch\n"
"float64        b_delta\n"
;
  }

  static const char* value(const ::custom_msgs::PoseCtrl_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.fl_x);
      stream.next(m.fl_z);
      stream.next(m.fr_x);
      stream.next(m.fr_z);
      stream.next(m.f_pitch);
      stream.next(m.f_delta);
      stream.next(m.bl_x);
      stream.next(m.bl_z);
      stream.next(m.br_x);
      stream.next(m.br_z);
      stream.next(m.b_pitch);
      stream.next(m.b_delta);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PoseCtrl_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::custom_msgs::PoseCtrl_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::custom_msgs::PoseCtrl_<ContainerAllocator>& v)
  {
    s << indent << "fl_x: ";
    Printer<double>::stream(s, indent + "  ", v.fl_x);
    s << indent << "fl_z: ";
    Printer<double>::stream(s, indent + "  ", v.fl_z);
    s << indent << "fr_x: ";
    Printer<double>::stream(s, indent + "  ", v.fr_x);
    s << indent << "fr_z: ";
    Printer<double>::stream(s, indent + "  ", v.fr_z);
    s << indent << "f_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.f_pitch);
    s << indent << "f_delta: ";
    Printer<double>::stream(s, indent + "  ", v.f_delta);
    s << indent << "bl_x: ";
    Printer<double>::stream(s, indent + "  ", v.bl_x);
    s << indent << "bl_z: ";
    Printer<double>::stream(s, indent + "  ", v.bl_z);
    s << indent << "br_x: ";
    Printer<double>::stream(s, indent + "  ", v.br_x);
    s << indent << "br_z: ";
    Printer<double>::stream(s, indent + "  ", v.br_z);
    s << indent << "b_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.b_pitch);
    s << indent << "b_delta: ";
    Printer<double>::stream(s, indent + "  ", v.b_delta);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CUSTOM_MSGS_MESSAGE_POSECTRL_H
